# 换热器性能监测系统 - 系统概要设计文档

**文档版本**：1.0  
**发布日期**：2026年1月4日  
**架构师**：系统架构师  
**目标读者**：前端开发工程师、后端开发工程师、测试工程师  

---

## 修订历史

| 版本 | 日期 | 修改人 | 修改描述 |
|------|------|--------|----------|
| 1.0 | 2026-01-04 | 系统架构师 | 初始版本创建，基于PRD文档 |

---

## 目录

1. [架构决策](#1-架构决策)
   - [1.1 整体技术架构](#11-整体技术架构)
   - [1.2 前端架构选型](#12-前端架构选型)
   - [1.3 后端架构概述](#13-后端架构概述)
   - [1.4 系统架构图](#14-系统架构图)
2. [模块分解](#2-模块分解)
   - [2.1 前端模块划分](#21-前端模块划分)
   - [2.2 模块职责与接口](#22-模块职责与接口)
   - [2.3 模块依赖关系](#23-模块依赖关系)
3. [关键技术方案](#3-关键技术方案)
   - [3.1 实时数据推送方案](#31-实时数据推送方案)
   - [3.2 数据可视化方案](#32-数据可视化方案)
   - [3.3 用户认证与授权方案](#33-用户认证与授权方案)
   - [3.4 状态管理方案](#34-状态管理方案)
   - [3.5 响应式与兼容性方案](#35-响应式与兼容性方案)
4. [数据模型设计](#4-数据模型设计)
   - [4.1 前端数据模型](#41-前端数据模型)
   - [4.2 状态数据结构](#42-状态数据结构)
   - [4.3 本地存储设计](#43-本地存储设计)
5. [非功能性设计](#5-非功能性设计)
   - [5.1 性能优化设计](#51-性能优化设计)
   - [5.2 安全性设计](#52-安全性设计)
   - [5.3 容错与可靠性设计](#53-容错与可靠性设计)
   - [5.4 兼容性设计](#54-兼容性设计)
   - [5.5 可维护性设计](#55-可维护性设计)

---

## 1. 架构决策

### 1.1 整体技术架构

#### 架构模式：前后端分离的单页应用（SPA）
- **前端**：Vite + Vue3 + JavaScript（ES6+）
- **后端**：FastAPI + MySQL（已存在）
- **通信**：RESTful API + SSE（Server-Sent Events）
- **部署**：前后端独立部署，通过Nginx反向代理

#### 架构选型理由
1. **Vue3框架优势**：
   - Composition API提供更好的逻辑复用
   - 优秀的响应式系统和性能优化
   - 丰富的生态系统和社区支持
   - 相比TypeScript，JavaScript降低学习成本，加快开发速度

2. **Vite构建工具优势**：
   - 极快的冷启动和热更新
   - 开箱即用的现代前端工具链
   - 支持ES模块原生导入

3. **前后端分离优势**：
   - 前后端独立开发、部署和扩展
   - 前端专注用户体验，后端专注业务逻辑
   - 支持多端复用API接口

### 1.2 前端架构选型

#### 技术栈清单
| 类别 | 技术选型 | 版本 | 选型理由 |
|------|----------|------|----------|
| **开发框架** | Vue 3 | 3.x | 渐进式框架，学习曲线平缓 |
| **构建工具** | Vite | 5.x | 极速构建，开发体验优秀 |
| **语言** | JavaScript (ES6+) | - | 降低TypeScript学习成本 |
| **路由管理** | Vue Router | 4.x | Vue官方路由，生态完善 |
| **状态管理** | Pinia | 2.x | Vue官方推荐，TypeScript友好 |
| **HTTP客户端** | Axios | 1.x | 广泛使用，拦截器完善 |
| **UI组件库** | Element Plus | 2.x | 企业级组件，设计规范 |
| **数据可视化** | ECharts | 5.x | 功能强大，定制灵活 |
| **图标库** | Material Design Icons | 最新 | 图标丰富，风格统一 |
| **CSS预处理器** | Sass/SCSS | 1.x | 变量、混合等高级特性 |
| **代码规范** | ESLint + Prettier | 最新 | 代码质量保障 |
| **测试框架** | Vitest + Vue Test Utils | 最新 | Vite生态，速度快 |

#### 项目结构设计
```
src/
├── api/                    # API接口封装
│   ├── auth.js            # 认证相关API
│   ├── heat-exchanger.js  # 换热器相关API
│   ├── realtime.js        # 实时数据API
│   └── index.js           # API统一导出
├── assets/                # 静态资源
│   ├── styles/           # 全局样式
│   └── images/           # 图片资源
├── components/           # 公共组件
│   ├── common/          # 通用组件
│   ├── charts/          # 图表组件
│   └── layout/          # 布局组件
├── composables/         # 组合式函数
│   ├── useRealtime.js   # 实时数据Hook
│   ├── useChart.js      # 图表Hook
│   └── useAuth.js       # 认证Hook
├── layouts/             # 布局组件
│   └── DefaultLayout.vue # 默认布局
├── router/              # 路由配置
│   └── index.js         # 路由定义
├── stores/              # Pinia状态管理
│   ├── auth.js          # 认证状态
│   ├── heat-exchanger.js # 换热器状态
│   └── alert.js         # 报警状态
├── utils/               # 工具函数
│   ├── request.js       # HTTP请求封装
│   ├── storage.js       # 本地存储工具
│   └── validator.js     # 表单验证工具
├── views/               # 页面组件
│   ├── Login.vue        # 登录页面
│   ├── Dashboard.vue    # 主页概览
│   ├── HeatExchangerDetail.vue # 换热器明细
│   └── SectionDetail.vue # 管段明细
└── main.js              # 应用入口
```

### 1.3 后端架构概述

基于现有后端系统（FastAPI + MySQL），前端需要对接的架构如下：

#### 后端服务分层
1. **API网关层**：FastAPI应用，提供RESTful接口和SSE推送
2. **业务逻辑层**：计算模块、数据处理模块
3. **数据访问层**：数据库连接和ORM操作
4. **数据库层**：MySQL双数据库（测试库+生产库）

#### 通信协议
- **HTTP/HTTPS**：常规API请求
- **SSE**：实时数据推送（单向，服务端→客户端）
- **WebSocket**：预留，用于未来双向实时通信需求

### 1.4 系统架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          系统整体架构图                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────┐      HTTP/HTTPS + SSE       ┌─────────────┐          │
│  │   前端应用    │◄──────────────────────────►│  后端API服务  │          │
│  │  (Vue3 SPA)  │                            │  (FastAPI)  │          │
│  └──────┬──────┘                            └──────┬──────┘          │
│         │                                          │                  │
│         │  localStorage   │  Nginx反向代理         │                  │
│         │  (JWT Token)    │                        │                  │
│         ▼                                          ▼                  │
│  ┌─────────────┐                            ┌─────────────┐          │
│  │   用户浏览器   │                            │   业务逻辑层  │          │
│  │  (Chrome等)  │                            │  (Python)   │          │
│  └─────────────┘                            └──────┬──────┘          │
│                                                     │                  │
│                                                     │ 数据库操作        │
│                                                     ▼                  │
│                                               ┌─────────────┐          │
│                                               │    MySQL    │          │
│                                               │  双数据库   │          │
│                                               └─────────────┘          │
│                                                                         │
│ 实时数据流：传感器 → 后端处理 → SSE推送 → 前端展示 → 用户              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 数据流说明
1. **用户请求流**：
   ```
   用户操作 → 前端Vue组件 → Axios请求 → 后端API → 数据库 → 返回结果 → 更新UI
   ```

2. **实时数据流**：
   ```
   传感器数据 → 后端采集处理 → SSE推送 → 前端EventSource监听 → 更新Pinia状态 → 组件响应式更新
   ```

3. **认证授权流**：
   ```
   用户登录 → 获取JWT Token → 存储localStorage → 后续请求携带Token → 后端验证 → 返回数据
   ```

---

## 2. 模块分解

### 2.1 前端模块划分

#### 核心功能模块
| 模块名称 | 模块标识 | 主要职责 | 技术实现 |
|----------|----------|----------|----------|
| **认证授权模块** | `auth` | 用户登录、注册、注销、权限验证 | Vue Router守卫、JWT、Pinia |
| **布局导航模块** | `layout` | 页面布局、侧边导航、顶部栏 | Vue组件、Vue Router |
| **换热器管理模块** | `heat-exchanger` | 换热器列表、明细、管段管理 | Vue组件、Pinia、ECharts |
| **实时数据模块** | `realtime` | SSE连接管理、实时数据更新 | EventSource、Pinia、Web Workers |
| **报警管理模块** | `alert` | 报警显示、确认、历史查询 | Web Notifications、Pinia |
| **数据可视化模块** | `chart` | 图表渲染、交互、数据转换 | ECharts、Vue组件封装 |
| **API服务模块** | `api` | HTTP请求封装、错误处理 | Axios、拦截器、统一错误处理 |
| **工具函数模块** | `utils` | 通用工具函数、表单验证 | 纯函数、工具类 |

#### 模块划分原则
1. **单一职责原则**：每个模块只负责一个明确的功能领域
2. **高内聚低耦合**：模块内部高度相关，模块间依赖清晰
3. **可测试性**：模块独立，便于单元测试
4. **可复用性**：通用模块可被多个页面复用

### 2.2 模块职责与接口

#### 2.2.1 认证授权模块 (`auth`)
**职责**：
- 用户登录、注册、注销功能
- JWT Token的存储、刷新和验证
- 路由权限守卫
- 用户信息管理

**对外接口**：
```javascript
// 模块导出接口
export const useAuth = () => {
  // 登录
  const login = async (username, password) => Promise<User>
  
  // 注销
  const logout = () => void
  
  // 检查登录状态
  const checkAuth = () => boolean
  
  // 获取当前用户
  const getCurrentUser = () => User | null
  
  // 检查权限
  const hasPermission = (permission) => boolean
  
  return {
    login,
    logout,
    checkAuth,
    getCurrentUser,
    hasPermission
  }
}
```

#### 2.2.2 API服务模块 (`api`)
**职责**：
- 统一HTTP请求配置
- 请求/响应拦截器
- 错误统一处理
- API接口封装

**对外接口**：
```javascript
// 请求实例
export const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000
})

// 接口封装示例
export const heatExchangerAPI = {
  // 获取换热器列表
  getHeatExchangers: () => request.get('/heat-exchangers'),
  
  // 获取运行参数
  getOperationParameters: (params) => 
    request.get('/operation-parameters', { params }),
  
  // 获取性能参数
  getPerformanceParameters: (params) =>
    request.get('/performance', { params }),
  
  // 处理数据
  processData: (day, hour) =>
    request.post(`/process-data/${day}/${hour}`)
}
```

#### 2.2.3 实时数据模块 (`realtime`)
**职责**：
- SSE连接建立和维护
- 实时数据解析和处理
- 连接状态管理
- 错误重连机制

**对外接口**：
```javascript
export const useRealtime = (heatExchangerId) => {
  // 连接SSE
  const connect = () => EventSource
  
  // 断开连接
  const disconnect = () => void
  
  // 监听事件
  const on = (eventName, callback) => void
  
  // 获取连接状态
  const getConnectionStatus = () => 'connected' | 'disconnected' | 'connecting'
  
  // 手动重连
  const reconnect = () => void
  
  return {
    connect,
    disconnect,
    on,
    getConnectionStatus,
    reconnect
  }
}
```

#### 2.2.4 状态管理模块 (`stores`)
**职责**：
- 全局状态管理
- 状态持久化
- 状态变更通知
- 状态序列化

**核心Store定义**：
```javascript
// auth store
export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: null,
    user: null,
    permissions: []
  }),
  actions: {
    setToken(token) { /* ... */ },
    setUser(user) { /* ... */ },
    clearAuth() { /* ... */ }
  },
  persist: true // 自动持久化到localStorage
})

// heat-exchanger store
export const useHeatExchangerStore = defineStore('heat-exchanger', {
  state: () => ({
    heatExchangers: [],
    currentHeatExchanger: null,
    currentSection: null,
    realtimeData: {}
  }),
  actions: {
    setHeatExchangers(data) { /* ... */ },
    setCurrentHeatExchanger(id) { /* ... */ },
    updateRealtimeData(data) { /* ... */ }
  }
})
```

### 2.3 模块依赖关系

```
┌─────────────────────────────────────────────────────────┐
│                   模块依赖关系图                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│                ┌─────────────┐                         │
│                │   入口文件    │                         │
│                │   (main.js)  │                         │
│                └──────┬──────┘                         │
│                       │                                  │
│          ┌────────────┴────────────┐                   │
│          ▼                         ▼                   │
│    ┌─────────────┐         ┌─────────────┐             │
│    │   路由模块    │         │  状态管理    │             │
│    │   (router)   │◄────────│   (stores)  │             │
│    └──────┬──────┘         └──────┬──────┘             │
│           │                        │                    │
│           ▼                        ▼                    │
│    ┌─────────────┐         ┌─────────────┐             │
│    │  页面组件     │         │  API服务    │             │
│    │   (views)    │◄────────│   (api)     │             │
│    └──────┬──────┘         └──────┬──────┘             │
│           │                        │                    │
│           └────────────┬───────────┘                    │
│                        ▼                               │
│                ┌─────────────┐                         │
│                │  公共组件     │                         │
│                │ (components) │                         │
│                └──────┬──────┘                         │
│                       │                                  │
│          ┌────────────┴────────────┐                   │
│          ▼                         ▼                   │
│    ┌─────────────┐         ┌─────────────┐             │
│    │ 组合式函数    │         │   工具函数    │             │
│    │(composables)│         │   (utils)   │             │
│    └─────────────┘         └─────────────┘             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**依赖说明**：
1. **单向依赖**：上层模块可以依赖下层模块，反之不行
2. **同级解耦**：同级模块通过接口通信，不直接依赖内部实现
3. **核心模块**：API服务和状态管理是核心枢纽模块

---

## 3. 关键技术方案

### 3.1 实时数据推送方案

#### 技术选型：Server-Sent Events (SSE)
**选型理由**：
1. **适用场景匹配**：只需要服务端向客户端单向推送
2. **实现简单**：基于HTTP协议，无需额外协议
3. **自动重连**：浏览器原生支持重连机制
4. **资源消耗低**：相比WebSocket连接更轻量

#### 实现方案
```javascript
// SSE连接管理类
class RealtimeService {
  constructor(heatExchangerId) {
    this.heatExchangerId = heatExchangerId
    this.eventSource = null
    this.reconnectAttempts = 0
    this.maxReconnectAttempts = 10
    this.reconnectDelay = 1000 // 初始重连延迟1秒
  }
  
  // 建立连接
  connect() {
    const url = `${import.meta.env.VITE_API_BASE_URL}/realtime-stream?heat_exchanger_id=${this.heatExchangerId}`
    
    this.eventSource = new EventSource(url, {
      headers: {
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      }
    })
    
    // 事件监听
    this.eventSource.addEventListener('parameters_update', this.handleParametersUpdate)
    this.eventSource.addEventListener('alert_new', this.handleNewAlert)
    this.eventSource.addEventListener('error', this.handleError)
    this.eventSource.addEventListener('open', this.handleOpen)
  }
  
  // 指数退避重连
  reconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached')
      return
    }
    
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts)
    this.reconnectAttempts++
    
    setTimeout(() => {
      console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`)
      this.connect()
    }, Math.min(delay, 30000)) // 最大延迟30秒
  }
  
  // 数据处理
  handleParametersUpdate(event) {
    const data = JSON.parse(event.data)
    // 更新Pinia状态
    useHeatExchangerStore().updateRealtimeData(data)
  }
  
  // 断开连接
  disconnect() {
    if (this.eventSource) {
      this.eventSource.close()
      this.eventSource = null
    }
  }
}
```

#### 性能优化措施
1. **数据压缩**：服务端对推送数据Gzip压缩
2. **批量更新**：前端对频繁更新进行防抖处理
3. **连接复用**：同一换热器多个页面共享连接
4. **心跳检测**：定时发送心跳包保持连接

### 3.2 数据可视化方案

#### 技术选型：ECharts 5.x
**选型理由**：
1. **功能丰富**：支持多种图表类型，满足监控需求
2. **性能优秀**：Canvas渲染，大数据量性能好
3. **定制灵活**：丰富的配置项和扩展机制
4. **文档完善**：中文文档齐全，社区活跃

#### 图表组件封装
```vue
<!-- ECharts Vue组件封装 -->
<template>
  <div ref="chartRef" :style="{ width, height }"></div>
</template>

<script>
import { ref, onMounted, onUnmounted, watch } from 'vue'
import * as echarts from 'echarts'

export default {
  name: 'BaseChart',
  props: {
    option: {
      type: Object,
      required: true
    },
    width: {
      type: String,
      default: '100%'
    },
    height: {
      type: String,
      default: '400px'
    },
    theme: {
      type: String,
      default: 'light'
    }
  },
  
  setup(props) {
    const chartRef = ref(null)
    let chartInstance = null
    
    // 初始化图表
    const initChart = () => {
      if (!chartRef.value) return
      
      chartInstance = echarts.init(chartRef.value, props.theme)
      chartInstance.setOption(props.option)
      
      // 响应窗口大小变化
      window.addEventListener('resize', handleResize)
    }
    
    // 更新图表
    const updateChart = () => {
      if (!chartInstance) return
      chartInstance.setOption(props.option, true)
    }
    
    // 处理窗口大小变化
    const handleResize = () => {
      if (chartInstance) {
        chartInstance.resize()
      }
    }
    
    // 监听option变化
    watch(() => props.option, updateChart, { deep: true })
    
    onMounted(initChart)
    onUnmounted(() => {
      if (chartInstance) {
        chartInstance.dispose()
        window.removeEventListener('resize', handleResize)
      }
    })
    
    return { chartRef }
  }
}
</script>
```

#### 监控图表类型设计
1. **趋势曲线图**：温度、压力、K值随时间变化
2. **仪表盘图**：实时数值展示，带阈值指示
3. **热力图**：多个管段参数对比
4. **散点图**：参数相关性分析

#### 性能优化
1. **数据采样**：大数据量时进行降采样显示
2. **懒加载**：非可视区域图表延迟初始化
3. **动画优化**：减少不必要的动画效果
4. **内存管理**：及时销毁不用的图表实例

### 3.3 用户认证与授权方案

#### JWT认证流程
```javascript
// 认证拦截器
request.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// 响应拦截器 - Token刷新
request.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config
    
    // Token过期，尝试刷新
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true
      
      try {
        const refreshToken = localStorage.getItem('refreshToken')
        const { data } = await request.post('/api/auth/refresh', { refreshToken })
        
        localStorage.setItem('token', data.token)
        originalRequest.headers.Authorization = `Bearer ${data.token}`
        
        return request(originalRequest)
      } catch (refreshError) {
        // 刷新失败，跳转到登录页
        router.push('/login')
        return Promise.reject(refreshError)
      }
    }
    
    return Promise.reject(error)
  }
)
```

#### 路由权限守卫
```javascript
// 路由守卫
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore()
  
  // 检查是否需要认证
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next('/login')
    return
  }
  
  // 检查角色权限
  if (to.meta.roles && !authStore.hasRole(to.meta.roles)) {
    next('/403') // 无权限页面
    return
  }
  
  // 检查特定权限
  if (to.meta.permissions && !authStore.hasPermission(to.meta.permissions)) {
    next('/403')
    return
  }
  
  next()
})
```

### 3.4 状态管理方案

#### Pinia状态设计原则
1. **单一状态树**：每个Store只管理一个领域的state
2. **响应式更新**：所有状态变更通过actions
3. **持久化策略**：重要状态自动持久化到localStorage
4. **类型安全**：虽用JavaScript，但通过JSDoc保证类型提示

#### 状态持久化配置
```javascript
// Pinia持久化插件配置
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)

// Store配置示例
export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: null,
    user: null
  }),
  
  persist: {
    key: 'heat-exchanger-auth',
    storage: localStorage,
    paths: ['token', 'user'] // 只持久化指定字段
  }
})
```

### 3.5 响应式与兼容性方案

#### 响应式设计
1. **移动端适配**：
   ```scss
   // 响应式断点
   $breakpoints: (
     'xs': 0,
     'sm': 576px,
     'md': 768px,
     'lg': 992px,
     'xl': 1200px,
     'xxl': 1400px
   );
   
   // 响应式mixin
   @mixin respond-to($breakpoint) {
     @media (min-width: map-get($breakpoints, $breakpoint)) {
       @content;
     }
   }
   ```

2. **Flexbox/Grid布局**：使用现代CSS布局方案
3. **rem单位**：基于根字体大小的相对单位

#### IE11兼容性
1. **Polyfill引入**：
   ```javascript
   // 入口文件引入polyfill
   import 'core-js/stable'
   import 'regenerator-runtime/runtime'
   ```

2. **构建配置**：
   ```javascript
   // vite.config.js
   export default defineConfig({
     build: {
       target: 'es2015' // 兼容IE11
     }
   })
   ```

3. **条件加载**：根据浏览器UA动态加载polyfill

---

## 4. 数据模型设计

### 4.1 前端数据模型

#### 核心数据模型定义
```javascript
// 用户模型
class User {
  constructor(data) {
    this.id = data.id
    this.username = data.username
    this.role = data.role // 'operator', 'engineer', 'admin'
    this.displayName = data.display_name
    this.permissions = data.permissions || []
    this.assignedHeatExchangers = data.assigned_heat_exchangers || []
  }
  
  hasPermission(permission) {
    return this.permissions.includes(permission)
  }
  
  canViewHeatExchanger(heatExchangerId) {
    if (this.role === 'admin' || this.role === 'engineer') {
      return true
    }
    return this.assignedHeatExchangers.includes(heatExchangerId)
  }
}

// 换热器模型
class HeatExchanger {
  constructor(data) {
    this.id = data.id
    this.name = data.name
    this.type = data.type
    this.tubeSideFluid = data.tube_side_fluid
    this.shellSideFluid = data.shell_side_fluid
    this.tubeSectionCount = data.tube_section_count
    this.shellSectionCount = data.shell_section_count
    this.healthStatus = data.health_status // 'normal', 'warning', 'fault'
    this.lastUpdate = new Date(data.last_update)
  }
  
  getHealthColor() {
    const colors = {
      normal: '#4caf50',
      warning: '#ff9800',
      fault: '#f44336'
    }
    return colors[this.healthStatus] || '#757575'
  }
}

// 管段模型
class TubeSection {
  constructor(data) {
    this.id = data.id
    this.heatExchangerId = data.heat_exchanger_id
    this.sectionNumber = data.section_number
    this.temperature = data.temperature
    this.pressure = data.pressure
    this.flowRate = data.flow_rate
    this.velocity = data.velocity
    this.kValue = data.k_value
    this.foulingResistance = data.fouling_resistance
    this.timestamp = new Date(data.timestamp)
  }
  
  getParameterTrend(paramName, historyData) {
    // 计算参数趋势
    const values = historyData.map(item => item[paramName])
    const current = this[paramName]
    const avg = values.reduce((a, b) => a + b, 0) / values.length
    
    return {
      current,
      average: avg,
      trend: current > avg ? 'up' : current < avg ? 'down' : 'stable',
      changeRate: ((current - avg) / avg * 100).toFixed(1)
    }
  }
}

// 报警模型
class Alert {
  constructor(data) {
    this.id = data.id
    this.level = data.level // 'warning', 'error', 'critical'
    this.timestamp = new Date(data.timestamp)
    this.heatExchangerId = data.heat_exchanger_id
    this.sectionNumber = data.section_number
    this.type = data.type
    this.message = data.message
    this.value = data.value
    this.threshold = data.threshold
    this.status = data.status // 'new', 'acknowledged', 'resolved'
  }
  
  getLevelColor() {
    const colors = {
      warning: '#ff9800',
      error: '#f44336',
      critical: '#d32f2f'
    }
    return colors[this.level] || '#757575'
  }
  
  getLevelText() {
    const texts = {
      warning: '警告',
      error: '错误',
      critical: '严重'
    }
    return texts[this.level] || '未知'
  }
}
```

### 4.2 状态数据结构

#### Pinia Store状态设计
```javascript
// 换热器Store状态
export const useHeatExchangerStore = defineStore('heat-exchanger', {
  state: () => ({
    // 换热器列表
    heatExchangers: {
      data: [],
      loading: false,
      error: null,
      lastUpdated: null
    },
    
    // 当前选中的换热器
    currentHeatExchanger: {
      id: null,
      data: null,
      loading: false,
      error: null
    },
    
    // 管段数据
    sections: {
      byHeatExchanger: {}, // { [heatExchangerId]: TubeSection[] }
      loading: false,
      error: null
    },
    
    // 实时数据
    realtimeData: {
      byHeatExchanger: {}, // { [heatExchangerId]: { [sectionNumber]: data } }
      lastUpdate: null,
      connectionStatus: 'disconnected'
    },
    
    // 历史数据
    historicalData: {
      byHeatExchanger: {}, // { [heatExchangerId]: { [param]: TimeSeriesData[] } }
      timeRange: '24h', // 24h, 7d, 30d
      loading: false
    }
  }),
  
  getters: {
    // 计算属性
    availableHeatExchangers: (state) => {
      const authStore = useAuthStore()
      return state.heatExchangers.data.filter(he => 
        authStore.user.canViewHeatExchanger(he.id)
      )
    },
    
    currentSections: (state) => {
      if (!state.currentHeatExchanger.id) return []
      return state.sections.byHeatExchanger[state.currentHeatExchanger.id] || []
    },
    
    currentRealtimeData: (state) => {
      if (!state.currentHeatExchanger.id) return {}
      return state.realtimeData.byHeatExchanger[state.currentHeatExchanger.id] || {}
    }
  },
  
  actions: {
    // 异步action
    async fetchHeatExchangers() {
      this.heatExchangers.loading = true
      try {
        const response = await heatExchangerAPI.getHeatExchangers()
        this.heatExchangers.data = response.data.map(item => new HeatExchanger(item))
        this.heatExchangers.lastUpdated = new Date()
      } catch (error) {
        this.heatExchangers.error = error.message
      } finally {
        this.heatExchangers.loading = false
      }
    },
    
    // 更新实时数据
    updateRealtimeData(payload) {
      const { heat_exchanger_id: heatExchangerId, data } = payload
      
      if (!this.realtimeData.byHeatExchanger[heatExchangerId]) {
        this.realtimeData.byHeatExchanger[heatExchangerId] = {}
      }
      
      // 更新数据
      this.realtimeData.byHeatExchanger[heatExchangerId][data.points] = data
      this.realtimeData.lastUpdate = new Date()
      
      // 触发UI更新
      this.$patch({})
    }
  }
})
```

### 4.3 本地存储设计

#### 存储策略
```javascript
// 本地存储工具类
class StorageManager {
  constructor() {
    this.prefix = 'heat_exchanger_'
  }
  
  // 存储JWT Token
  setToken(token) {
    localStorage.setItem(`${this.prefix}token`, token)
  }
  
  getToken() {
    return localStorage.getItem(`${this.prefix}token`)
  }
  
  removeToken() {
    localStorage.removeItem(`${this.prefix}token`)
  }
  
  // 存储用户偏好
  setUserPreference(key, value) {
    const preferences = this.getUserPreferences()
    preferences[key] = value
    localStorage.setItem(`${this.prefix}preferences`, JSON.stringify(preferences))
  }
  
  getUserPreferences() {
    const data = localStorage.getItem(`${this.prefix}preferences`)
    return data ? JSON.parse(data) : {}
  }
  
  // 清理所有存储
  clearAll() {
    const keys = Object.keys(localStorage)
    keys.forEach(key => {
      if (key.startsWith(this.prefix)) {
        localStorage.removeItem(key)
      }
    })
  }
  
  // 数据缓存
  setCache(key, data, ttl = 300000) { // 默认5分钟
    const cacheItem = {
      data,
      expiry: Date.now() + ttl
    }
    localStorage.setItem(`${this.prefix}cache_${key}`, JSON.stringify(cacheItem))
  }
  
  getCache(key) {
    const item = localStorage.getItem(`${this.prefix}cache_${key}`)
    if (!item) return null
    
    const cacheItem = JSON.parse(item)
    if (Date.now() > cacheItem.expiry) {
      localStorage.removeItem(`${this.prefix}cache_${key}`)
      return null
    }
    
    return cacheItem.data
  }
}
```

#### 缓存策略设计
1. **短期缓存**：换热器列表、用户信息（5分钟）
2. **长期缓存**：静态配置、图标资源（1天）
3. **实时数据**：不缓存，始终获取最新
4. **历史数据**：按时间范围缓存，过期自动清理

---

## 5. 非功能性设计

### 5.1 性能优化设计

#### 5.1.1 加载性能优化
1. **代码分割**：
   ```javascript
   // 路由懒加载
   const Login = () => import('@/views/Login.vue')
   const Dashboard = () => import('@/views/Dashboard.vue')
   ```

2. **资源优化**：
   - 图片压缩和WebP格式
   - 字体子集化
   - 第三方库按需引入

3. **预加载策略**：
   ```javascript
   // 关键资源预加载
   <link rel="preload" href="/assets/fonts/roboto.woff2" as="font" type="font/woff2" crossorigin>
   ```

#### 5.1.2 运行时性能优化
1. **虚拟滚动**：大数据列表使用虚拟滚动
2. **防抖节流**：频繁操作使用防抖节流
3. **内存管理**：及时清理不需要的监听器和定时器
4. **Web Workers**：复杂计算放在Worker线程

#### 5.1.3 网络性能优化
1. **HTTP/2**：启用HTTP/2多路复用
2. **资源压缩**：Gzip/Brotli压缩
3. **缓存策略**：合理的Cache-Control设置
4. **CDN加速**：静态资源使用CDN

### 5.2 安全性设计

#### 5.2.1 前端安全措施
1. **XSS防护**：
   ```javascript
   // 输入输出转义
   const sanitizeHTML = (str) => {
     const div = document.createElement('div')
     div.textContent = str
     return div.innerHTML
   }
   ```

2. **CSRF防护**：
   ```javascript
   // 请求头添加CSRF Token
   request.defaults.headers.common['X-CSRF-Token'] = getCSRFToken()
   ```

3. **Content Security Policy**：
   ```html
   <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;">
   ```

#### 5.2.2 认证安全
1. **Token存储**：HttpOnly Cookie + localStorage双重存储
2. **Token刷新**：短期Access Token + 长期Refresh Token
3. **会话管理**：用户主动注销时Token立即失效
4. **安全传输**：强制HTTPS，HSTS头部

#### 5.2.3 数据安全
1. **敏感数据脱敏**：关键数据显示时脱敏
2. **本地存储加密**：敏感信息加密存储
3. **日志脱敏**：日志中不记录敏感信息

### 5.3 容错与可靠性设计

#### 5.3.1 错误边界
```vue
<template>
  <ErrorBoundary>
    <slot />
  </ErrorBoundary>
</template>

<script>
import { defineComponent, h } from 'vue'

export default defineComponent({
  name: 'ErrorBoundary',
  
  data() {
    return {
      error: null,
      errorInfo: null
    }
  },
  
  errorCaptured(err, vm, info) {
    this.error = err
    this.errorInfo = info
    
    // 错误上报
    this.reportError(err, info)
    
    return false // 阻止错误继续向上传播
  },
  
  methods: {
    reportError(error, info) {
      // 上报到监控系统
      console.error('Component Error:', error, info)
    }
  },
  
  render() {
    if (this.error) {
      return h('div', { class: 'error-boundary' }, [
        h('h2', '组件加载失败'),
        h('button', { onClick: () => window.location.reload() }, '重新加载')
      ])
    }
    
    return this.$slots.default?.()
  }
})
</script>
```

#### 5.3.2 网络容错
1. **请求重试**：失败请求自动重试（指数退避）
2. **降级方案**：接口失败时显示缓存数据
3. **超时处理**：合理设置请求超时时间
4. **心跳检测**：实时连接心跳检测

#### 5.3.3 数据一致性
1. **乐观更新**：先更新UI，再同步到服务器
2. **冲突解决**：数据冲突时用户确认
3. **离线支持**：Service Worker缓存关键页面
4. **同步机制**：网络恢复时自动同步

### 5.4 兼容性设计

#### 5.4.1 浏览器兼容
1. **分级支持**：
   - A级：Chrome 90+、Edge 90+、Firefox 88+（完全支持）
   - B级：Safari 14+、IE 11（基本功能）

2. **特性检测**：
   ```javascript
   // 检测浏览器特性
   const supports = {
     sse: 'EventSource' in window,
     webp: (() => {
       const canvas = document.createElement('canvas')
       return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0
     })(),
     flexbox: 'flex' in document.documentElement.style
   }
   ```

#### 5.4.2 设备兼容
1. **响应式布局**：移动端、平板、桌面三端适配
2. **触摸优化**：移动端触摸事件优化
3. **键盘导航**：支持完整键盘操作
4. **屏幕阅读器**：ARIA标签和语义化HTML

### 5.5 可维护性设计

#### 5.5.1 代码组织规范
1. **目录结构**：按功能模块组织，见[1.2节](#12-前端架构选型)
2. **命名规范**：
   - 组件：PascalCase，如 `HeatExchangerCard.vue`
   - 工具函数：camelCase，如 `formatTemperature()`
   - 常量：UPPER_SNAKE_CASE，如 `API_TIMEOUT`

3. **代码分割**：
   - 单文件不超过500行
   - 单个函数不超过50行
   - 按功能拆分组合式函数

#### 5.5.2 文档与注释
1. **JSDoc注释**：
   ```javascript
   /**
    * 获取换热器的平均温度
    * @param {HeatExchanger} heatExchanger - 换热器对象
    * @param {string} side - 侧别：'tube' 或 'shell'
    * @returns {number} 平均温度（摄氏度）
    */
   function getAverageTemperature(heatExchanger, side) {
     // 实现
   }
   ```

2. **组件文档**：每个组件有README说明
3. **API文档**：自动生成的接口文档

#### 5.5.3 测试策略
1. **单元测试**：工具函数、组合式函数
2. **组件测试**：Vue组件渲染和交互
3. **集成测试**：完整用户流程
4. **E2E测试**：关键业务路径

#### 5.5.4 监控与日志
1. **性能监控**：页面加载时间、接口响应时间
2. **错误监控**：前端错误收集和上报
3. **用户行为**：关键操作埋点
4. **日志分级**：开发、测试、生产不同日志级别

---

## 附录

### A. 部署架构

```
生产环境部署架构：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户访问        │    │   Nginx反向代理   │    │   前端静态资源    │
│   (浏览器)       │───►│   (负载均衡)      │───►│   (CDN/对象存储)  │
└─────────────────┘    └────────┬────────┘    └─────────────────┘
                                 │
                                 ▼
                        ┌─────────────────┐    ┌─────────────────┐
                        │  后端API服务      │    │    MySQL数据库    │
                        │  (FastAPI)      │◄──►│   (主从复制)     │
                        └─────────────────┘    └─────────────────┘
```

### B. 开发环境配置

```javascript
// .env.development
VITE_API_BASE_URL=http://localhost:8000
VITE_APP_TITLE=换热器监测系统(开发环境)
VITE_DEBUG=true

// .env.production
VITE_API_BASE_URL=https://api.heat-exchanger.com
VITE_APP_TITLE=换热器性能监测系统
VITE_DEBUG=false
```

### C. 性能预算

| 指标 | 目标值 | 监控方式 |
|------|--------|----------|
| 首次内容绘制 (FCP) | ≤ 1.5s | Lighthouse |
| 最大内容绘制 (LCP) | ≤ 2.5s | Lighthouse |
| 累积布局偏移 (CLS) | ≤ 0.1 | Lighthouse |
| 首次输入延迟 (FID) | ≤ 100ms | Lighthouse |
| 页面加载时间 | ≤ 3s | 自定义监控 |
| 接口响应时间 P90 | ≤ 500ms | 后端监控 |
| 实时数据延迟 | ≤ 10s | 前端时间戳 |

### D. 风险评估与应对

| 风险项 | 可能性 | 影响程度 | 应对措施 |
|--------|--------|----------|----------|
| 实时数据延迟过高 | 中 | 高 | 降级到轮询、增加本地缓存 |
| 浏览器兼容性问题 | 低 | 中 | 渐进增强、优雅降级 |
| 后端API不稳定 | 中 | 高 | 请求重试、降级展示 |
| 用户网络差 | 高 | 中 | 离线模式、数据预加载 |
| 安全漏洞 | 低 | 高 | 定期安全审计、依赖更新 |

---

**文档状态**：✅ 设计完成  
**下一阶段**：详细设计 → 编码实现 → 测试验证 → 部署上线

*本文档作为前端系统开发的指导性文档，开发过程中需严格遵循设计原则和规范。*