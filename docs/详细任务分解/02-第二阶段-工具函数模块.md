# 第二阶段：工具函数模块 - 详细任务分解

**阶段目标**：实现通用的工具函数库和本地存储管理工具，提供项目中常用的数据处理、格式化、验证和存储功能  
**预估工期**：2人日  
**关键产出**：完整可用的工具函数库，支持日期时间格式化、数值单位转换、数据验证、防抖节流、本地存储管理等功能

---

## 任务清单

### T2.2.1 实现通用工具函数

#### 任务描述
1. **日期时间格式化工具**：
   - 实现多种日期时间格式转换
   - 支持相对时间显示（如"刚刚"、"3分钟前"）
   - 支持时区转换和国际化

2. **数值单位转换工具**：
   - 温度单位转换（℃、℉、K）
   - 压力单位转换（Pa、kPa、MPa、bar）
   - 流量单位转换（m³/h、L/s）
   - 数据大小单位转换（B、KB、MB、GB）

3. **数据验证工具函数**：
   - 表单字段验证（邮箱、手机号、URL等）
   - 数值范围验证
   - 必填字段验证
   - 自定义验证规则

4. **防抖节流工具函数**：
   - 防抖函数实现
   - 节流函数实现
   - 支持立即执行和取消功能

#### 技术细节与实现步骤

**步骤1：创建日期时间工具**
```javascript
// src/utils/date-time.js
/**
 * 日期时间工具函数
 */

/**
 * 日期时间格式化
 * @param {Date|string|number} date - 日期对象、时间戳或日期字符串
 * @param {string} format - 格式字符串
 * @returns {string} 格式化后的日期字符串
 */
export function formatDateTime(date, format = 'YYYY-MM-DD HH:mm:ss') {
  if (!date) return ''
  
  const d = new Date(date)
  if (isNaN(d.getTime())) return ''
  
  const pad = (n) => n.toString().padStart(2, '0')
  
  const replacements = {
    YYYY: d.getFullYear(),
    YY: d.getFullYear().toString().slice(-2),
    MM: pad(d.getMonth() + 1),
    M: d.getMonth() + 1,
    DD: pad(d.getDate()),
    D: d.getDate(),
    HH: pad(d.getHours()),
    H: d.getHours(),
    hh: pad(d.getHours() % 12 || 12),
    h: d.getHours() % 12 || 12,
    mm: pad(d.getMinutes()),
    m: d.getMinutes(),
    ss: pad(d.getSeconds()),
    s: d.getSeconds(),
    SSS: pad(d.getMilliseconds(), 3),
    A: d.getHours() < 12 ? 'AM' : 'PM',
    a: d.getHours() < 12 ? 'am' : 'pm'
  }
  
  return format.replace(/YYYY|YY|MM|M|DD|D|HH|H|hh|h|mm|m|ss|s|SSS|A|a/g, match => replacements[match])
}

/**
 * 相对时间显示
 * @param {Date|string|number} date - 日期
 * @returns {string} 相对时间字符串
 */
export function formatRelativeTime(date) {
  if (!date) return ''
  
  const d = new Date(date)
  if (isNaN(d.getTime())) return ''
  
  const now = new Date()
  const diffInSeconds = Math.floor((now - d) / 1000)
  
  if (diffInSeconds < 60) {
    return '刚刚'
  }
  
  const diffInMinutes = Math.floor(diffInSeconds / 60)
  if (diffInMinutes < 60) {
    return `${diffInMinutes}分钟前`
  }
  
  const diffInHours = Math.floor(diffInMinutes / 60)
  if (diffInHours < 24) {
    return `${diffInHours}小时前`
  }
  
  const diffInDays = Math.floor(diffInHours / 24)
  if (diffInDays < 7) {
    return `${diffInDays}天前`
  }
  
  const diffInWeeks = Math.floor(diffInDays / 7)
  if (diffInWeeks < 4) {
    return `${diffInWeeks}周前`
  }
  
  const diffInMonths = Math.floor(diffInDays / 30)
  if (diffInMonths < 12) {
    return `${diffInMonths}个月前`
  }
  
  const diffInYears = Math.floor(diffInDays / 365)
  return `${diffInYears}年前`
}

/**
 * 获取友好的时间显示
 * @param {Date|string|number} date - 日期
 * @returns {string} 友好的时间字符串
 */
export function formatFriendlyTime(date) {
  if (!date) return ''
  
  const d = new Date(date)
  if (isNaN(d.getTime())) return ''
  
  const now = new Date()
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate())
  const yesterday = new Date(today)
  yesterday.setDate(yesterday.getDate() - 1)
  
  const targetDate = new Date(d.getFullYear(), d.getMonth(), d.getDate())
  
  if (targetDate.getTime() === today.getTime()) {
    return `今天 ${formatDateTime(d, 'HH:mm')}`
  } else if (targetDate.getTime() === yesterday.getTime()) {
    return `昨天 ${formatDateTime(d, 'HH:mm')}`
  } else if (now.getTime() - d.getTime() < 7 * 24 * 60 * 60 * 1000) {
    const weekdays = ['周日', '周一', '周二', '周三', '周四', '周五', '周六']
    return `${weekdays[d.getDay()]} ${formatDateTime(d, 'HH:mm')}`
  } else {
    return formatDateTime(d, 'YYYY-MM-DD HH:mm')
  }
}

/**
 * 解析日期字符串
 * @param {string} dateString - 日期字符串
 * @returns {Date|null} 日期对象
 */
export function parseDateString(dateString) {
  if (!dateString) return null
  
  // 尝试多种格式解析
  const parsers = [
    (str) => new Date(str), // ISO格式
    (str) => {
      const match = str.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/)
      if (match) {
        return new Date(match[1], match[2] - 1, match[3])
      }
      return null
    },
    (str) => {
      const match = str.match(/^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/)
      if (match) {
        return new Date(match[1], match[2] - 1, match[3], match[4], match[5], match[6])
      }
      return null
    }
  ]
  
  for (const parser of parsers) {
    const result = parser(dateString)
    if (result && !isNaN(result.getTime())) {
      return result
    }
  }
  
  return null
}

/**
 * 计算时间间隔
 * @param {Date|string|number} start - 开始时间
 * @param {Date|string|number} end - 结束时间
 * @returns {Object} 时间间隔对象
 */
export function calculateTimeInterval(start, end) {
  const startDate = new Date(start)
  const endDate = new Date(end)
  
  if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
    return null
  }
  
  const diffInMs = Math.abs(endDate - startDate)
  const diffInSeconds = Math.floor(diffInMs / 1000)
  const diffInMinutes = Math.floor(diffInSeconds / 60)
  const diffInHours = Math.floor(diffInMinutes / 60)
  const diffInDays = Math.floor(diffInHours / 24)
  
  return {
    milliseconds: diffInMs,
    seconds: diffInSeconds,
    minutes: diffInMinutes,
    hours: diffInHours,
    days: diffInDays,
    formatted: formatTimeInterval(diffInMs)
  }
}

/**
 * 格式化时间间隔
 * @param {number} milliseconds - 毫秒数
 * @returns {string} 格式化的时间间隔
 */
export function formatTimeInterval(milliseconds) {
  if (milliseconds < 1000) {
    return `${milliseconds}ms`
  }
  
  const seconds = Math.floor(milliseconds / 1000)
  if (seconds < 60) {
    return `${seconds}秒`
  }
  
  const minutes = Math.floor(seconds / 60)
  if (minutes < 60) {
    const remainingSeconds = seconds % 60
    return remainingSeconds > 0 
      ? `${minutes}分${remainingSeconds}秒`
      : `${minutes}分钟`
  }
  
  const hours = Math.floor(minutes / 60)
  if (hours < 24) {
    const remainingMinutes = minutes % 60
    return remainingMinutes > 0
      ? `${hours}小时${remainingMinutes}分`
      : `${hours}小时`
  }
  
  const days = Math.floor(hours / 24)
  const remainingHours = hours % 24
  if (remainingHours > 0) {
    return `${days}天${remainingHours}小时`
  }
  
  return `${days}天`
}
```

**步骤2：创建数值单位转换工具**
```javascript
// src/utils/unit-converter.js
/**
 * 数值单位转换工具
 */

/**
 * 温度单位转换
 * @param {number} value - 温度值
 * @param {string} fromUnit - 原单位 ('C', 'F', 'K')
 * @param {string} toUnit - 目标单位 ('C', 'F', 'K')
 * @returns {number} 转换后的温度值
 */
export function convertTemperature(value, fromUnit, toUnit) {
  if (fromUnit === toUnit) return value
  
  // 先转换为摄氏度
  let celsius
  switch (fromUnit.toUpperCase()) {
    case 'C':
      celsius = value
      break
    case 'F':
      celsius = (value - 32) * 5 / 9
      break
    case 'K':
      celsius = value - 273.15
      break
    default:
      throw new Error(`不支持的温度单位: ${fromUnit}`)
  }
  
  // 从摄氏度转换为目标单位
  switch (toUnit.toUpperCase()) {
    case 'C':
      return celsius
    case 'F':
      return celsius * 9 / 5 + 32
    case 'K':
      return celsius + 273.15
    default:
      throw new Error(`不支持的温度单位: ${toUnit}`)
  }
}

/**
 * 压力单位转换
 * @param {number} value - 压力值
 * @param {string} fromUnit - 原单位 ('Pa', 'kPa', 'MPa', 'bar', 'atm')
 * @param {string} toUnit - 目标单位
 * @returns {number} 转换后的压力值
 */
export function convertPressure(value, fromUnit, toUnit) {
  if (fromUnit === toUnit) return value
  
  // 转换表（以Pa为基准）
  const toPaFactors = {
    'pa': 1,
    'kpa': 1000,
    'mpa': 1000000,
    'bar': 100000,
    'atm': 101325
  }
  
  const fromFactor = toPaFactors[fromUnit.toLowerCase()]
  const toFactor = toPaFactors[toUnit.toLowerCase()]
  
  if (!fromFactor || !toFactor) {
    throw new Error(`不支持的压力单位: ${fromUnit} 或 ${toUnit}`)
  }
  
  // 先转换为Pa，再转换为目标单位
  const valueInPa = value * fromFactor
  return valueInPa / toFactor
}

/**
 * 流量单位转换
 * @param {number} value - 流量值
 * @param {string} fromUnit - 原单位 ('m3/h', 'l/s', 'kg/s')
 * @param {string} toUnit - 目标单位
 * @param {number} density - 流体密度 (kg/m³)，用于质量流量转换
 * @returns {number} 转换后的流量值
 */
export function convertFlowRate(value, fromUnit, toUnit, density = 1000) {
  if (fromUnit === toUnit) return value
  
  // 体积流量转换（以m³/s为基准）
  const toM3sFactors = {
    'm3/s': 1,
    'm3/h': 1 / 3600,
    'l/s': 0.001,
    'l/h': 0.001 / 3600
  }
  
  // 如果是质量流量，先转换为体积流量
  let volumeFlowRate
  if (fromUnit.toLowerCase() === 'kg/s') {
    volumeFlowRate = value / density // kg/s -> m³/s
  } else {
    const fromFactor = toM3sFactors[fromUnit.toLowerCase()]
    if (!fromFactor) {
      throw new Error(`不支持的流量单位: ${fromUnit}`)
    }
    volumeFlowRate = value * fromFactor
  }
  
  // 转换为目标单位
  if (toUnit.toLowerCase() === 'kg/s') {
    return volumeFlowRate * density
  }
  
  const toFactor = toM3sFactors[toUnit.toLowerCase()]
  if (!toFactor) {
    throw new Error(`不支持的流量单位: ${toUnit}`)
  }
  
  return volumeFlowRate / toFactor
}

/**
 * 数据大小单位转换
 * @param {number} bytes - 字节数
 * @param {string} toUnit - 目标单位 ('B', 'KB', 'MB', 'GB', 'TB')
 * @param {number} decimals - 小数位数
 * @returns {string} 转换后的数据大小字符串
 */
export function formatFileSize(bytes, toUnit = 'auto', decimals = 2) {
  if (bytes === 0) return '0 B'
  
  const k = 1024
  const units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
  
  // 自动选择合适单位
  if (toUnit === 'auto') {
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    const value = bytes / Math.pow(k, i)
    return `${value.toFixed(decimals)} ${units[i]}`
  }
  
  // 转换为指定单位
  const unitIndex = units.indexOf(toUnit.toUpperCase())
  if (unitIndex === -1) {
    throw new Error(`不支持的数据大小单位: ${toUnit}`)
  }
  
  const value = bytes / Math.pow(k, unitIndex)
  return `${value.toFixed(decimals)} ${units[unitIndex]}`
}

/**
 * 数值格式化（添加千位分隔符）
 * @param {number} value - 数值
 * @param {number} decimals - 小数位数
 * @returns {string} 格式化后的数值字符串
 */
export function formatNumber(value, decimals = 2) {
  if (value === null || value === undefined || isNaN(value)) {
    return '0'
  }
  
  const number = parseFloat(value)
  const fixed = number.toFixed(decimals)
  
  // 添加千位分隔符
  const parts = fixed.split('.')
  parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',')
  
  return parts.join('.')
}

/**
 * 百分比格式化
 * @param {number} value - 百分比值（0-1或0-100）
 * @param {boolean} isDecimal - 是否为小数形式（0-1）
 * @param {number} decimals - 小数位数
 * @returns {string} 格式化后的百分比字符串
 */
export function formatPercent(value, isDecimal = true, decimals = 1) {
  if (value === null || value === undefined || isNaN(value)) {
    return '0%'
  }
  
  const percentValue = isDecimal ? value * 100 : value
  const formatted = percentValue.toFixed(decimals)
  
  // 移除不必要的尾随零
  const cleanValue = formatted.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '')
  
  return `${cleanValue}%`
}
```

**步骤3：创建数据验证工具**
```javascript
// src/utils/validator.js
/**
 * 数据验证工具函数
 */

/**
 * 验证电子邮件地址
 * @param {string} email - 电子邮件地址
 * @returns {boolean} 是否有效
 */
export function isValidEmail(email) {
  if (!email) return false
  
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email.trim())
}

/**
 * 验证手机号码（中国）
 * @param {string} phone - 手机号码
 * @returns {boolean} 是否有效
 */
export function isValidPhone(phone) {
  if (!phone) return false
  
  const phoneRegex = /^1[3-9]\d{9}$/
  return phoneRegex.test(phone.trim())
}

/**
 * 验证URL地址
 * @param {string} url - URL地址
 * @returns {boolean} 是否有效
 */
export function isValidUrl(url) {
  if (!url) return false
  
  try {
    new URL(url)
    return true
  } catch {
    return false
  }
}

/**
 * 验证身份证号码（中国）
 * @param {string} idCard - 身份证号码
 * @returns {boolean} 是否有效
 */
export function isValidIdCard(idCard) {
  if (!idCard) return false
  
  // 简单验证：15位或18位数字，最后一位可以是X
  const idCardRegex = /(^\d{15}$)|(^\d{17}(\d|X|x)$)/
  if (!idCardRegex.test(idCard)) {
    return false
  }
  
  // 如果是18位，验证校验码
  if (idCard.length === 18) {
    const weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]
    const checkCodes = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2']
    
    let sum = 0
    for (let i = 0; i < 17; i++) {
      sum += parseInt(idCard[i]) * weights[i]
    }
    
    const checkCode = checkCodes[sum % 11]
    return idCard[17].toUpperCase() === checkCode
  }
  
  return true
}

/**
 * 验证数值范围
 * @param {number} value - 数值
 * @param {number} min - 最小值
 * @param {number} max - 最大值
 * @returns {boolean} 是否在范围内
 */
export function isInRange(value, min, max) {
  if (value === null || value === undefined) return false
  const num = parseFloat(value)
  return !isNaN(num) && num >= min && num <= max
}

/**
 * 验证必填字段
 * @param {*} value - 字段值
 * @returns {boolean} 是否非空
 */
export function isRequired(value) {
  if (value === null || value === undefined) return false
  
  if (typeof value === 'string') {
    return value.trim().length > 0
  }
  
  if (Array.isArray(value)) {
    return value.length > 0
  }
  
  if (typeof value === 'object') {
    return Object.keys(value).length > 0
  }
  
  return true
}

/**
 * 验证密码强度
 * @param {string} password - 密码
 * @returns {Object} 验证结果
 */
export function validatePassword(password) {
  if (!password) {
    return {
      isValid: false,
      strength: 0,
      errors: ['密码不能为空']
    }
  }
  
  const errors = []
  let strength = 0
  
  // 长度检查
  if (password.length >= 8) {
    strength += 1
  } else {
    errors.push('密码长度至少8位')
  }
  
  // 包含小写字母
  if (/[a-z]/.test(password)) {
    strength += 1
  } else {
    errors.push('至少包含一个小写字母')
  }
  
  // 包含大写字母
  if (/[A-Z]/.test(password)) {
    strength += 1
  } else {
    errors.push('至少包含一个大写字母')
  }
  
  // 包含数字
  if (/\d/.test(password)) {
    strength += 1
  } else {
    errors.push('至少包含一个数字')
  }
  
  // 包含特殊字符
  if (/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
    strength += 1
  }
  
  return {
    isValid: errors.length === 0,
    strength: strength,
    errors: errors,
    strengthText: getPasswordStrengthText(strength)
  }
}

/**
 * 获取密码强度文本
 */
function getPasswordStrengthText(strength) {
  if (strength <= 2) return '弱'
  if (strength === 3) return '中'
  if (strength === 4) return '强'
  return '非常强'
}

/**
 * 创建验证器
 * @param {Object} rules - 验证规则
 * @returns {Function} 验证函数
 */
export function createValidator(rules) {
  return function(value, fieldName = '字段') {
    const errors = []
    
    for (const [ruleName, ruleConfig] of Object.entries(rules)) {
      let isValid = true
      let message = ''
      
      switch (ruleName) {
        case 'required':
          if (!isRequired(value)) {
            isValid = false
            message = ruleConfig.message || `${fieldName}不能为空`
          }
          break
          
        case 'email':
          if (value && !isValidEmail(value)) {
            isValid = false
            message = ruleConfig.message || '请输入有效的电子邮件地址'
          }
          break
          
        case 'phone':
          if (value && !isValidPhone(value)) {
            isValid = false
            message = ruleConfig.message || '请输入有效的手机号码'
          }
          break
          
        case 'min':
          if (value !== null && value !== undefined && parseFloat(value) < ruleConfig.value) {
            isValid = false
            message = ruleConfig.message || `${fieldName}不能小于${ruleConfig.value}`
          }
          break
          
        case 'max':
          if (value !== null && value !== undefined && parseFloat(value) > ruleConfig.value) {
            isValid = false
            message = ruleConfig.message || `${fieldName}不能大于${ruleConfig.value}`
          }
          break
          
        case 'minLength':
          if (value && value.length < ruleConfig.value) {
            isValid = false
            message = ruleConfig.message || `${fieldName}长度不能小于${ruleConfig.value}个字符`
          }
          break
          
        case 'maxLength':
          if (value && value.length > ruleConfig.value) {
            isValid = false
            message = ruleConfig.message || `${fieldName}长度不能大于${ruleConfig.value}个字符`
          }
          break
          
        case 'pattern':
          if (value && !ruleConfig.regex.test(value)) {
            isValid = false
            message = ruleConfig.message || `${fieldName}格式不正确`
          }
          break
          
        case 'custom':
          if (value && !ruleConfig.validator(value)) {
            isValid = false
            message = ruleConfig.message || `${fieldName}验证失败`
          }
          break
      }
      
      if (!isValid) {
        errors.push(message)
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors: errors
    }
  }
}
```

**步骤4：创建防抖节流工具**
```javascript
// src/utils/debounce-throttle.js
/**
 * 防抖和节流工具函数
 */

/**
 * 防抖函数
 * @param {Function} func - 需要防抖的函数
 * @param {number} wait - 等待时间（毫秒）
 * @param {boolean} immediate - 是否立即执行
 * @returns {Function} 防抖处理后的函数
 */
export function debounce(func, wait = 300, immediate = false) {
  let timeout = null
  let result
  
  const debounced = function(...args) {
    const context = this
    
    // 清除之前的定时器
    if (timeout) {
      clearTimeout(timeout)
    }
    
    // 立即执行模式
    if (immediate) {
      const callNow = !timeout
      timeout = setTimeout(() => {
        timeout = null
      }, wait)
      
      if (callNow) {
        result = func.apply(context, args)
      }
    } else {
      // 延迟执行模式
      timeout = setTimeout(() => {
        func.apply(context, args)
      }, wait)
    }
    
    return result
  }
  
  // 取消功能
  debounced.cancel = function() {
    if (timeout) {
      clearTimeout(timeout)
      timeout = null
    }
  }
  
  // 立即执行功能
  debounced.flush = function() {
    if (timeout) {
      clearTimeout(timeout)
      timeout = null
      return func.apply(this, arguments)
    }
  }
  
  return debounced
}

/**
 * 节流函数
 * @param {Function} func - 需要节流的函数
 * @param {number} wait - 等待时间（毫秒）
 * @param {Object} options - 选项
 * @returns {Function} 节流处理后的函数
 */
export function throttle(func, wait = 300, options = {}) {
  let timeout = null
  let previous = 0
  let result
  
  // 默认选项
  const { leading = true, trailing = true } = options
  
  const throttled = function(...args) {
    const context = this
    const now = Date.now()
    
    // 如果不是首次执行且leading为false，则重置previous
    if (!previous && !leading) {
      previous = now
    }
    
    // 计算剩余时间
    const remaining = wait - (now - previous)
    
    // 如果剩余时间小于等于0或者大于等待时间（系统时间被调整）
    if (remaining <= 0 || remaining > wait) {
      // 清除定时器
      if (timeout) {
        clearTimeout(timeout)
        timeout = null
      }
      
      previous = now
      result = func.apply(context, args)
    } else if (!timeout && trailing) {
      // 如果需要尾部执行
      timeout = setTimeout(() => {
        previous = leading ? Date.now() : 0
        timeout = null
        result = func.apply(context, args)
      }, remaining)
    }
    
    return result
  }
  
  // 取消功能
  throttled.cancel = function() {
    if (timeout) {
      clearTimeout(timeout)
      timeout = null
      previous = 0
    }
  }
  
  // 立即执行功能
  throttled.flush = function() {
    if (timeout) {
      clearTimeout(timeout)
      timeout = null
      previous = Date.now()
      return func.apply(this, arguments)
    }
  }
  
  return throttled
}

/**
 * 防抖装饰器（用于类方法）
 * @param {number} wait - 等待时间
 * @param {boolean} immediate - 是否立即执行
 * @returns {Function} 装饰器函数
 */
export function debounceDecorator(wait = 300, immediate = false) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value
    const debounced = debounce(originalMethod, wait, immediate)
    
    descriptor.value = function(...args) {
      return debounced.apply(this, args)
    }
    
    return descriptor
  }
}

/**
 * 节流装饰器（用于类方法）
 * @param {number} wait - 等待时间
 * @param {Object} options - 选项
 * @returns {Function} 装饰器函数
 */
export function throttleDecorator(wait = 300, options = {}) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value
    const throttled = throttle(originalMethod, wait, options)
    
    descriptor.value = function(...args) {
      return throttled.apply(this, args)
    }
    
    return descriptor
  }
}
```

#### 验收条件
1. **日期时间工具验证**：
   - 日期时间格式化功能正常
   - 相对时间显示正确
   - 时区转换和国际化支持

2. **单位转换验证**：
   - 温度、压力、流量单位转换正确
   - 数据大小格式化功能正常
   - 数值格式化（千位分隔符）正确

3. **数据验证验证**：
   - 各种验证函数能正确判断
   - 密码强度验证准确
   - 自定义验证器工作正常

4. **防抖节流验证**：
   - 防抖函数能有效控制函数执行频率
   - 节流函数能按指定频率执行
   - 取消和立即执行功能正常

#### 产出物清单
- ✓ src/utils/date-time.js（日期时间工具）
- ✓ src/utils/unit-converter.js（单位转换工具）
- ✓ src/utils/validator.js（数据验证工具）
- ✓ src/utils/debounce-throttle.js（防抖节流工具）
- ✓ 完整的工具函数库
- ✓ 装饰器支持
- ✓ 错误处理和边界情况处理

---

### T2.2.2 实现本地存储工具

#### 任务描述
1. **封装localStorage操作**：
   - 统一的前缀和命名空间管理
   - 类型安全的数据读写
   - 数据版本管理

2. **实现数据缓存机制**：
   - 带TTL（生存时间）的缓存
   - 缓存清理和过期检查
   - 缓存命中统计

3. **实现存储加密基础功能**：
   - 敏感数据加密存储
   - 加密密钥管理
   - 安全存储实践

4. **实现存储空间管理**：
   - 存储空间使用统计
   - 自动清理过期数据
   - 存储配额管理

#### 技术细节与实现步骤

**步骤1：创建本地存储工具**
```javascript
// src/utils/storage.js
/**
 * 本地存储工具
 */

// 存储前缀，避免与其他应用冲突
const STORAGE_PREFIX = 'heat_exchanger_'
const STORAGE_VERSION = '1.0'

/**
 * 本地存储管理器
 */
class StorageManager {
  constructor(options = {}) {
    this.options = {
      prefix: STORAGE_PREFIX,
      version: STORAGE_VERSION,
      encryption: false,
      compress: false,
      ...options
    }
    
    // 检查localStorage是否可用
    this.isAvailable = this.checkLocalStorageAvailability()
    
    // 初始化存储版本
    if (this.isAvailable) {
      this.initStorageVersion()
    }
  }
  
  /**
   * 检查localStorage是否可用
   */
  checkLocalStorageAvailability() {
    try {
      const testKey = '__storage_test__'
      localStorage.setItem(testKey, testKey)
      localStorage.removeItem(testKey)
      return true
    } catch (error) {
      console.error('localStorage不可用:', error)
      return false
    }
  }
  
  /**
   * 初始化存储版本
   */
  initStorageVersion() {
    const versionKey = this.getKey('storage_version')
    const currentVersion = localStorage.getItem(versionKey)
    
    if (!currentVersion) {
      // 第一次使用，设置版本
      localStorage.setItem(versionKey, this.options.version)
    } else if (currentVersion !== this.options.version) {
      // 版本升级，执行迁移逻辑
      this.migrateStorage(currentVersion, this.options.version)
      localStorage.setItem(versionKey, this.options.version)
    }
  }
  
  /**
   * 存储版本迁移
   */
  migrateStorage(fromVersion, toVersion) {
    console.log(`正在迁移存储版本: ${fromVersion} -> ${toVersion}`)
    
    // 这里可以根据版本差异执行不同的迁移逻辑
    // 例如清理旧格式数据、转换数据结构等
    
    // 简单实现：清理所有旧数据
    this.clearAll()
  }
  
  /**
   * 获取完整的存储键名
   */
  getKey(key) {
    return `${this.options.prefix}${key}`
  }
  
  /**
   * 设置存储项
   */
  setItem(key, value, options = {}) {
    if (!this.isAvailable) {
      console.warn('localStorage不可用，无法设置存储项')
      return false
    }
    
    try {
      const storageKey = this.getKey(key)
      const storageValue = this.prepareValueForStorage(value, options)
      
      localStorage.setItem(storageKey, storageValue)
      return true
    } catch (error) {
      console.error(`设置存储项失败 (${key}):`, error)
      return false
    }
  }
  
  /**
   * 获取存储项
   */
  getItem(key, defaultValue = null) {
    if (!this.isAvailable) {
      return defaultValue
    }
    
    try {
      const storageKey = this.getKey(key)
      const storedValue = localStorage.getItem(storageKey)
      
      if (storedValue === null) {
        return defaultValue
      }
      
      return this.parseValueFromStorage(storedValue)
    } catch (error) {
      console.error(`获取存储项失败 (${key}):`, error)
      return defaultValue
    }
  }
  
  /**
   * 删除存储项
   */
  removeItem(key) {
    if (!this.isAvailable) {
      return false
    }
    
    try {
      const storageKey = this.getKey(key)
      localStorage.removeItem(storageKey)
      return true
    } catch (error) {
      console.error(`删除存储项失败 (${key}):`, error)
      return false
    }
  }
  
  /**
   * 清空所有存储项
   */
  clearAll() {
    if (!this.isAvailable) {
      return false
    }
    
    try {
      // 只清理带有前缀的项
      const keysToRemove = []
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i)
        if (key.startsWith(this.options.prefix)) {
          keysToRemove.push(key)
        }
      }
      
      keysToRemove.forEach(key => {
        localStorage.removeItem(key)
      })
      
      return true
    } catch (error) {
      console.error('清空存储失败:', error)
      return false
    }
  }
  
  /**
   * 准备存储值
   */
  prepareValueForStorage(value, options) {
    const storageItem = {
      value: value,
      timestamp: Date.now(),
      ttl: options.ttl || null, // 生存时间（毫秒）
      version: this.options.version
    }
    
    // 如果需要加密
    if (this.options.encryption && options.encrypt !== false) {
      storageItem.value = this.encryptValue(value)
      storageItem.encrypted = true
    }
    
    // 如果需要压缩
    if (this.options.compress && options.compress !== false) {
      storageItem.value = this.compressValue(JSON.stringify(storageItem.value))
      storageItem.compressed = true
    }
    
    return JSON.stringify(storageItem)
  }
  
  /**
   * 解析存储值
   */
  parseValueFromStorage(storedValue) {
    try {
      const storageItem = JSON.parse(storedValue)
      
      // 检查是否过期
      if (storageItem.ttl && Date.now() - storageItem.timestamp > storageItem.ttl) {
        this.removeItem(storageItem.key) // 需要从外部传递key
        return null
      }
      
      let value = storageItem.value
      
      // 如果被压缩，先解压缩
      if (storageItem.compressed) {
        value = this.decompressValue(value)
        value = JSON.parse(value)
      }
      
      // 如果被加密，先解密
      if (storageItem.encrypted) {
        value = this.decryptValue(value)
      }
      
      return value
    } catch (error) {
      console.error('解析存储值失败:', error)
      return null
    }
  }
  
  /**
   * 简单的加密（实际项目中应该使用更安全的加密方法）
   */
  encryptValue(value) {
    // 注意：这里只是示例，实际项目中应该使用安全的加密库
    // 例如 crypto-js 或 Web Crypto API
    try {
      return btoa(JSON.stringify(value))
    } catch {
      return value
    }
  }
  
  /**
   * 解密
   */
  decryptValue(encryptedValue) {
    try {
      return JSON.parse(atob(encryptedValue))
    } catch {
      return encryptedValue
    }
  }
  
  /**
   * 简单的压缩（实际项目中应该使用更高效的压缩算法）
   */
  compressValue(value) {
    // 注意：这里只是示例，实际项目中可以使用 pako 等压缩库
    try {
      return btoa(value)
    } catch {
      return value
    }
  }
  
  /**
   * 解压缩
   */
  decompressValue(compressedValue) {
    try {
      return atob(compressedValue)
    } catch {
      return compressedValue
    }
  }
  
  /**
   * 获取存储统计信息
   */
  getStorageStats() {
    if (!this.isAvailable) {
      return null
    }
    
    const stats = {
      totalItems: 0,
      totalSize: 0,
      itemsByType: {},
      expiredItems: 0
    }
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i)
      
      if (key.startsWith(this.options.prefix)) {
        stats.totalItems++
        
        const value = localStorage.getItem(key)
        stats.totalSize += key.length + (value ? value.length : 0)
        
        try {
          const storageItem = JSON.parse(value)
          const itemType = typeof storageItem.value
          stats.itemsByType[itemType] = (stats.itemsByType[itemType] || 0) + 1
          
          // 检查是否过期
          if (storageItem.ttl && Date.now() - storageItem.timestamp > storageItem.ttl) {
            stats.expiredItems++
          }
        } catch {
          // 忽略解析失败的项目
        }
      }
    }
    
    return stats
  }
  
  /**
   * 清理过期项目
   */
  cleanupExpiredItems() {
    if (!this.isAvailable) {
      return 0
    }
    
    let removedCount = 0
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i)
      
      if (key.startsWith(this.options.prefix)) {
        try {
          const value = localStorage.getItem(key)
          const storageItem = JSON.parse(value)
          
          if (storageItem.ttl && Date.now() - storageItem.timestamp > storageItem.ttl) {
            localStorage.removeItem(key)
            removedCount++
          }
        } catch {
          // 忽略解析失败的项目
        }
      }
    }
    
    return removedCount
  }
  
  /**
   * 获取所有键名
   */
  getAllKeys() {
    if (!this.isAvailable) {
      return []
    }
    
    const keys = []
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i)
      if (key.startsWith(this.options.prefix)) {
        // 移除前缀
        const cleanKey = key.slice(this.options.prefix.length)
        keys.push(cleanKey)
      }
    }
    
    return keys
  }
}

// 创建默认实例
export const storage = new StorageManager()

// 导出工具函数
export const storageUtils = {
  /**
   * 设置带TTL的缓存
   */
  setWithTTL(key, value, ttl = 3600000) { // 默认1小时
    return storage.setItem(key, value, { ttl })
  },
  
  /**
   * 获取缓存，如果过期返回null
   */
  getWithTTL(key, defaultValue = null) {
    return storage.getItem(key, defaultValue)
  },
  
  /**
   * 存储JSON数据
   */
  setJSON(key, value) {
    return storage.setItem(key, value)
  },
  
  /**
   * 获取JSON数据
   */
  getJSON(key, defaultValue = null) {
    return storage.getItem(key, defaultValue)
  },
  
  /**
   * 存储字符串
   */
  setString(key, value) {
    return storage.setItem(key, String(value))
  },
  
  /**
   * 获取字符串
   */
  getString(key, defaultValue = '') {
    const value = storage.getItem(key, defaultValue)
    return String(value)
  },
  
  /**
   * 存储数字
   */
  setNumber(key, value) {
    return storage.setItem(key, Number(value))
  },
  
  /**
   * 获取数字
   */
  getNumber(key, defaultValue = 0) {
    const value = storage.getItem(key, defaultValue)
    const num = Number(value)
    return isNaN(num) ? defaultValue : num
  },
  
  /**
   * 存储布尔值
   */
  setBoolean(key, value) {
    return storage.setItem(key, Boolean(value))
  },
  
  /**
   * 获取布尔值
   */
  getBoolean(key, defaultValue = false) {
    const value = storage.getItem(key, defaultValue)
    return Boolean(value)
  },
  
  /**
   * 存储数组
   */
  setArray(key, value) {
    if (!Array.isArray(value)) {
      value = []
    }
    return storage.setItem(key, value)
  },
  
  /**
   * 获取数组
   */
  getArray(key, defaultValue = []) {
    const value = storage.getItem(key, defaultValue)
    return Array.isArray(value) ? value : defaultValue
  },
  
  /**
   * 存储对象
   */
  setObject(key, value) {
    if (typeof value !== 'object' || value === null) {
      value = {}
    }
    return storage.setItem(key, value)
  },
  
  /**
   * 获取对象
   */
  getObject(key, defaultValue = {}) {
    const value = storage.getItem(key, defaultValue)
    return typeof value === 'object' && value !== null ? value : defaultValue
  },
  
  /**
   * 检查键是否存在
   */
  has(key) {
    return storage.getItem(key) !== null
  },
  
  /**
   * 获取存储统计
   */
  getStats() {
    return storage.getStorageStats()
  },
  
  /**
   * 清理过期项目
   */
  cleanup() {
    return storage.cleanupExpiredItems()
  },
  
  /**
   * 获取所有键
   */
  keys() {
    return storage.getAllKeys()
  }
}

// 默认导出
export default storage
```

**步骤2：创建缓存管理器**
```javascript
// src/utils/cache-manager.js
/**
 * 缓存管理器
 */

import { storageUtils } from './storage'

/**
 * 缓存管理器类
 */
export class CacheManager {
  constructor(options = {}) {
    this.options = {
      namespace: 'cache',
      defaultTTL: 3600000, // 默认1小时
      maxSize: 50, // 最大缓存项数
      cleanupInterval: 300000, // 清理间隔（5分钟）
      ...options
    }
    
    this.cacheStats = {
      hits: 0,
      misses: 0,
      size: 0,
      lastCleanup: Date.now()
    }
    
    // 启动定期清理
    this.startCleanupInterval()
  }
  
  /**
   * 生成缓存键
   */
  generateCacheKey(key) {
    return `${this.options.namespace}_${key}`
  }
  
  /**
   * 获取缓存
   */
  get(key) {
    const cacheKey = this.generateCacheKey(key)
    const cached = storageUtils.getWithTTL(cacheKey)
    
    if (cached !== null) {
      this.cacheStats.hits++
      return cached
    } else {
      this.cacheStats.misses++
      return null
    }
  }
  
  /**
   * 设置缓存
   */
  set(key, value, ttl = this.options.defaultTTL) {
    const cacheKey = this.generateCacheKey(key)
    const success = storageUtils.setWithTTL(cacheKey, value, ttl)
    
    if (success) {
      this.updateCacheSize()
    }
    
    return success
  }
  
  /**
   * 删除缓存
   */
  delete(key) {
    const cacheKey = this.generateCacheKey(key)
    storageUtils.removeItem(cacheKey)
    this.updateCacheSize()
  }
  
  /**
   * 清空所有缓存
   */
  clear() {
    const keys = storageUtils.keys()
    
    keys.forEach(key => {
      if (key.startsWith(`${this.options.namespace}_`)) {
        storageUtils.removeItem(key)
      }
    })
    
    this.cacheStats.size = 0
  }
  
  /**
   * 获取或设置缓存（如果不存在）
   */
  async getOrSet(key, fetchFunction, ttl = this.options.defaultTTL) {
    const cached = this.get(key)
    
    if (cached !== null) {
      return cached
    }
    
    // 获取新数据
    try {
      const data = await fetchFunction()
      this.set(key, data, ttl)
      return data
    } catch (error) {
      console.error(`获取缓存数据失败 (${key}):`, error)
      throw error
    }
  }
  
  /**
   * 更新缓存大小统计
   */
  updateCacheSize() {
    const keys = storageUtils.keys()
    let size = 0
    
    keys.forEach(key => {
      if (key.startsWith(`${this.options.namespace}_`)) {
        size++
      }
    })
    
    this.cacheStats.size = size
    
    // 如果超过最大大小，清理最旧的缓存
    if (size > this.options.maxSize) {
      this.cleanupOldest(size - this.options.maxSize)
    }
  }
  
  /**
   * 清理最旧的缓存
   */
  cleanupOldest(count = 10) {
    const cacheItems = []
    const keys = storageUtils.keys()
    
    // 收集缓存项信息
    keys.forEach(key => {
      if (key.startsWith(`${this.options.namespace}_`)) {
        const value = localStorage.getItem(key)
        if (value) {
          try {
            const item = JSON.parse(value)
            cacheItems.push({
              key: key,
              timestamp: item.timestamp || 0
            })
          } catch {
            // 忽略解析失败的项
          }
        }
      }
    })
    
    // 按时间排序
    cacheItems.sort((a, b) => a.timestamp - b.timestamp)
    
    // 删除最旧的项
    const itemsToRemove = cacheItems.slice(0, Math.min(count, cacheItems.length))
    itemsToRemove.forEach(item => {
      storageUtils.removeItem(item.key)
    })
    
    this.cacheStats.size -= itemsToRemove.length
    return itemsToRemove.length
  }
  
  /**
   * 启动定期清理
   */
  startCleanupInterval() {
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpired()
    }, this.options.cleanupInterval)
  }
  
  /**
   * 清理过期缓存
   */
  cleanupExpired() {
    const removed = storageUtils.cleanup()
    if (removed > 0) {
      console.log(`清理了 ${removed} 个过期缓存项`)
    }
    
    this.cacheStats.lastCleanup = Date.now()
    this.updateCacheSize()
  }
  
  /**
   * 获取缓存统计
   */
  getStats() {
    return {
      ...this.cacheStats,
      hitRate: this.cacheStats.hits + this.cacheStats.misses > 0
        ? (this.cacheStats.hits / (this.cacheStats.hits + this.cacheStats.misses)).toFixed(3)
        : 0
    }
  }
  
  /**
   * 销毁缓存管理器
   */
  destroy() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval)
      this.cleanupInterval = null
    }
  }
}

// 创建默认缓存管理器实例
export const cacheManager = new CacheManager()

// 导出便捷函数
export const cache = {
  get: (key) => cacheManager.get(key),
  set: (key, value, ttl) => cacheManager.set(key, value, ttl),
  delete: (key) => cacheManager.delete(key),
  clear: () => cacheManager.clear(),
  getOrSet: (key, fetchFunction, ttl) => cacheManager.getOrSet(key, fetchFunction, ttl),
  getStats: () => cacheManager.getStats()
}
```

#### 验收条件
1. **本地存储功能验证**：
   - 能正确读写localStorage数据
   - 类型安全的数据转换正常
   - 版本迁移功能正常工作

2. **缓存机制验证**：
   - TTL缓存能正确过期
   - 缓存清理功能正常
   - 缓存统计准确

3. **存储管理验证**：
   - 存储空间统计准确
   - 自动清理功能正常
   - 存储配额管理有效

4. **安全存储验证**：
   - 敏感数据能正确加密（示例级别）
   - 存储键名隔离良好
   - 错误处理完善

#### 产出物清单
- ✓ src/utils/storage.js（本地存储工具）
- ✓ src/utils/cache-manager.js（缓存管理器）
- ✓ 完整的本地存储管理功能
- ✓ 带TTL的缓存机制
- ✓ 存储统计和清理功能
- ✓ 类型安全的数据访问接口

---

## 模块完成标准

### 总体验收条件
1. **工具函数完整性**：
   - 日期时间、单位转换、数据验证、防抖节流工具齐全
   - 所有工具函数有完善的单元测试
   - 函数功能正确，边界情况处理完善

2. **本地存储可靠性**：
   - 本地存储操作稳定可靠
   - 缓存机制能有效提高性能
   - 数据安全存储有基础保障

3. **代码质量优秀**：
   - 代码文档注释完整
   - 类型提示完善（通过JSDoc）
   - 错误处理全面

4. **性能优化到位**：
   - 防抖节流能有效控制函数执行频率
   - 缓存能有效减少重复请求
   - 内存管理良好

### 产出物总览
- ✓ 完整的通用工具函数库
- ✓ 完整的本地存储管理工具
- ✓ 带TTL的缓存管理系统
- ✓ 类型安全的数据访问接口
- ✓ 完善的错误处理机制

### 下一模块准备
完成本模块后，项目已具备：
1. 丰富的工具函数支持
2. 可靠的本地存储管理
3. 高效的缓存机制
4. 完善的数据验证能力

可以进入下一模块：认证授权模块开发
